# JAVA STANDARD [ 자바의 정석 ]

# Chapter 06 객체지향 프로그래밍 I
### 클래스와 객체(class & object)
- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.
- 참고 : 자신을 참조하고 있는 참조변수가 하나도 없는 인스턴스는 더 이상 사용되어질 수 없으므로 '가비지 컬렉터'에 의해서 자동적으로 메모리에서 제거된다.
- 데이터 저장 개념
  - 변수 : 하나의 데이터를 저장할 수 있는 공간
  - 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
  - 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
  - 클래스 : 데이터와 함수의 결합(구조체 + 함수)

### 변수와 메서드(variable & method)
- 변수
  - 인스턴스변수(instance variable) : 클래스 영역에 선언. 독립적인 저장공간
  - 클래스변수(class variable) : 모든 인스턴스가 공통된 저장공간(변수)을 공유, 인스턴수변수와 달리 인스턴스를 생성하지 않고도 바로 사용 가능, 메모리에 `로딩(loading)`될 때 생성 -> 종료까지 유지
  - 지역변수(local variable) : 메서드 내에 선언되어 메서드 내에서만 사용 가능, 지역변수가 선언된 `블럭 {}` 내에서만 사용 가능
- 인스턴스변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공톤된 값을 갖는다.
- 메서드를 사용하는 이유
  - 높은 재사용성(reusability)
  - 중복된 코드의 제거
  - 프로그램의 구조화
    - 처음에 프로그램을 설계할 때 내용이 없는 메서드를 작업단위로 만들어놓고, 하나씩 완성해가는 것도 프로그램을 구조화하는 좋은 방법
  - 메서드를 작성할 때는 매개변수의 유효성을 검사하는 코드를 반드시 넣자. 매개변수의 유효성 검사는 메서드의 작성에 있어서 간과하기 쉬운 중요한 부분이다.
- JVM의 메모리 구조
  - 메서드 영역(method area)
    - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이 때, 그 클래스의 클래스변수 (class variable)도 이 영역에 함께 생성된다.
  - 힙(heap)
    - 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스변수(instance variable)들이 생성되는 공간이다.
  - 호출스택(call stack 또는 execution stack)
    - 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.
      - 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
      - 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
      - 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
      - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
- 기본형 매개변수와 참조형 매개변수
  - 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다. (read only)
  - 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다. (read & write)
- 참조형 반환타입
  - "반환타입이 `참조형`이라는 것은 메서드가 `객체의 주소`를 반환한다는 것을 의미한다."
- 이처럼 우리가 메서드를 작성할 때, `호출하는 사람이 당연히 알아서 적절한 값을 인자로 주겠지.`라는 막연한 믿음을 가져서는 안 되고, 어떤 값이 들어와도 에러없이 처리되는 견고한 코드를 작성해야 한다.
- 클래스 메서드(static 메서드)와 인스턴스 메서드
  - 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다.
  - 인스턴스와 관계없은(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드를 클래스 메서드(static 메서드)로 정의한다.
    - 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
    - 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
    - 클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다.
    - 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.
- 클래스 멤버와 인스턴스 멤버간의 참조와 호출
  - 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있다.
  - 인스턴스멤버간의 호출에는 아무런 문제가 없다. 하나의 인스턴스멤버가 존재한다는 것은 인스턴스가 이미 생성되어있다는 것을 의미하며, 즉 다른 인스턴스멤버들도 모두 존재하기 때문이다.

### 오버로딩(overloading)
- 오버로딩의 조건
  - 메서드 이름이 같아야 한다.
  - 매개변수의 개수 또는 타입이 달라야 한다.
- 가변인자(varargs)와 오버로딩
  - `타입... 변수명`과 같은 형식으로 선언
  - 가변인자를 매개변수 중에서 제일 마지막에 선언해야 함

### 생성자(constructor)
- 생성자의 이름은 클래스의 이름과 같아야 한다
- 생성자는 리턴 값이 없다.
- 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.
- Card c = new Card();
  - 연산자 new에 의해서 메모리(heap)에 Card 클래스의 인스턴스가 생성된다.
  - 생성자 Card()가 호출되어 수행된다.
  - 연산자 new의 결과로, 생성된 Card 인스턴스의 주소가 반환되어 참조변수 c에 저장된다.
- 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.
- 생성자의 이름으로 클래스이름 대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
- this : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다.
- this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.
- 인스턴스를 생성할 때는 다음의 2가지 사항을 결정해야한다.
  - 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
  - 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

### 변수의 초기화
- 지역변수는 사용하기 전에 반드시 초기화해야 한다.
- 멤버변수(클래스변수와 인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.
- 멤버변수의 초기화 방법
  - 명시적 초기화 (explicit initialization)
  - 생성자 (constructor)
  - 초기화 블럭 (initialization block)
    - 인스턴스 초기화 블럭 : 인스턴스변수를 초기화 하는데 사용
    - 클래스 초기화 블럭 : 클래스변수를 초기화 하는데 사용
- 초기화 블럭 (initialization block)
  - 클래스 초기화 블럭 : 클래스변수의 복잡한 초기화에 사용된다.
  - 인스턴스 초기화 블럭 : 인스턴스변수의 복잡한 초기화에 사용된다.
- 멤버변수의 초기화 시기와 순서
  - 클래스변수의 초기화시점 : 클래스가 처음 로딩될 때 단 한번 초기화된다.
  - 인스턴스변수의 초기화시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.
  - 클래스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
  - 인스턴스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자

# Chapter 07 객체지향 프로그래밍 II
### 상속(inheritance)
- 조상클래스 : 부모(parent) 클래스, 상위(super) 클래스, 기반(base) 클래스
- 자손클래스 : 자식(child) 클래스, 하위(sub) 클래스, 파생된(derived) 클래스
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
  - 참고 : 접근 제어자(access modifier)가 private 또는 default인 멤버들은 상속되지 않는다기보다 상속은 받지만 자손 클래스로부터의 접근이 제한되는 것이다.
- 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.
- 클래스를 가지고 문장을 만들었을 때 `'~은 ~이다(is-a)'.`라는 문장이 성립한다면, 서로 상속관계를 맺어 주고 `'~은 ~을 가지고 있다(has-a).는 문장이 성립한다면 포함관계를 맺어주면 된다.'`
  - 상속관계 : '~은 ~이다.(is-a)'
  - 포함관계 : '~은 ~을 가지고 있다.(has-a)'
- 참고 : 이미 어떤 클래스로부터 상속받도록 작성된 클래스에 대해서는 컴파일러가 'extends Object'를 추가하지 않는다.

### 오버라이딩(overriding)
- 오버라이딩의 조건
  - 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
    - `이름이 같아야 한다.`
    - `매개변수가 같아야 한다.`
    - `반환타입이 같아야 한다.`
  - 조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
    - 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
    - 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
    - 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.
- 오버로딩(overloading) : 기존에 없는 새로운 메서드를 정의하는 것(new)
- 오버라이딩(overriding) : 상속받은 메서드의 내용을 변경하는 것(change, modify)
- Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this() 또는 super()를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.
- 인스턴스를 생성할 때는 클래스를 선택하는 것만큼 생성자를 선택하는 것도 중요하다.
  - 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
  - 생성자 - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?

### 패키지(package)
- 클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.
  - 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
  - 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
  - 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.
  - 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.

### 제어자(modifier)
- 제어자(modifier)는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.
  - 접근 제어자 : public, protected, default, private
  - 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
    - private : 같은 클래스 내에서만 접근이 가능하다.
    - default : 같은 패키지 내에서만 접근이 가능하다.
    - protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
    - public : 접근 제한이 전혀 없다.
    - public > protected > (default) > private
  - 접근 제어자를 사용하는 이유
    - 외부로부터 데이터를 보호하기 위해서
    - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
  - 제어자 조합 사용 주의 사항
    - 메서드에 static과 abstract를 함께 사용할 수없다.
      - static 메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.
    - 클래스에 abstract와 final을 동시에 사용할 수 없다.
      - 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.
    - abstract 메서드의 접근 제어자가 private일 수 없다.
      - abstract 메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없기 때문이다.
    - 메서드에 private과 final을 같이 사용할 필요는 없다.
      - 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.

### 다형성(polymorphism)
- 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.
- CaptionTv c = new CaptionTv(); Tv t = new CaptionTv();
  - 둘 다 같은 타입의 인스턴스이지만 참조변수의 타입에 따라 사용할 수 있는데 멤버의 개수가 달라진다.
- 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.
- 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
- 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수 없다.
- 자손타입 -> 조상타입(Up-casting) : 형변환 생략 가능
- 자손타입 <- 조상타입(Down-casting) : 형변환 생략불가
- 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조 변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다. 단지 참조 변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것뿐이다.
- 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다. 그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.
- 어떤 타입에 대한 instanceof 연산의 결과가 true 라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

### 추상클래스(abstract class)
- 클래스가 미완성이라는 것은 멤버의 개수에 관계된 것이 아니라, 단지 미완성 메서드(추상메서드)를 포함하고 있다는 의미이다.
- 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다.
  - abstract 리턴타입 메서드이름();
- 추상 : 낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작용
- 추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
- 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업

### 인터페이스(interface)
- 일종의 추상클래스이다. 추상클래스보다 추상화 정도가 높다.
- 추상클래스를 부분적으로만 완성된 `미완성 설계도`라고 한다면, 인터페이스는 구현된 것은 아무 것도 없고 밑그림만 그려져 있는 `기본 설계도`라 할 수 있다.
- 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
- 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
  - 단, static 메서드와 디폴트 메서드는 예외(JDK1.8부터)
- 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.
- 인터페이스의 장점
  - 개발시간을 단축시킬 수 있다.
  - 표준화가 가능하다.
  - 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
  - 독립적인 프로그래밍이 가능하다.

